# LSV PA2 report

> Task: Testing Unateness of Primary Outputs
---
## Algorithm

Function $f$ is said to be positive unate in variable $x$ if

$$f_{\neg{x}}\subseteq f_x$$

which is equivalent to:

$$f_{\neg{x}}\rightarrow f_x$$

To verify if the above relationship holds, we can formulate an expression as

$$f_{\neg{x}}\wedge \neg{f_x}$$

If the expression is satisfiable, it means that we can find a variable assignment to make $f_{\neg{x}}$ true while making $f_x$ false, thus $f_{\neg{x}}$ does not imply $f_x$, and therefore $f$ is not positive unate in variable $x$. On the contrary, if the expression is unsatisfiable, then it implies that $f$ is positive unate in $x$. Therefore, by solving the SAT problem with  the above expression,  we can know whether $f$ is positive unate in $x$.

Similarly, to check if $f$ is negative unate in $x$, we can solve the SAT problem with the expression of:

$$\neg{f_{\neg{x}}}\wedge {f_x}$$
---
## Implementation Steps

For each PO, do:

1. Get the single output network

    ```cpp
    Abc_Ntk_t* poNtk = Abc_NtkCreateCone(pNtk, Abc_ObjFanin0(pObj), Abc_ObjName(pObj), 0);
    ```

2. Obtain the AIG circuit of the network

    ```cpp
    Aig_Man_t* pAig = Abc_NtkToDar(poNtk,0,0);
    ```

3. Derive the CNF formula of the AIG circuit

    ```cpp
    Cnf_Dat_t* pCnf = Cnf_Derive( pAig, Aig_ManCoNum(pAig) );
    ```

4. Duplicate the CNF formula (We need to perform positive cofactor on one CNF and negative cofactor on another) and lift the variables

    ```cpp
    Cnf_Dat_t* negpCnf = Cnf_DataDup(pCnf);
    Cnf_DataLift(negpCnf, pCnf -> nVars);
    ```

5. Set up the SAT solver

    ```cpp
    sat_solver* pSat = sat_solver_new();
    sat_solver_setnvars(pSat, pCnf->nVars * 2 + Aig_ManCiNum(pAig));
    ```

6. Add the clauses of the two CNF formula into SAT solver

    ```cpp
    for(int i = 0; i < pCnf -> nClauses; ++i){
      sat_solver_addclause(pSat, *((pCnf -> pClauses) + i), *((pCnf -> pClauses) + i + 1));
    }
    for(int i = 0; i < negpCnf -> nClauses; ++i){
      sat_solver_addclause(pSat, *((negpCnf -> pClauses) + i), *((negpCnf -> pClauses) + i + 1));
    }
    ```

7. Add clauses to assert equivalence between the corresponding CI's of the circuit 

    ```cpp
    Aig_ManForEachCi(pCnf->pMan, aObj, v){ 
        sat_solver_add_buffer_enable(pSat, pCnf->pVarNums[aObj->Id], pCnf->pVarNums[aObj->Id] + pCnf -> nVars, pCnf -> nVars * 2+ v, 0);
        assumptions[v] = (pCnf -> nVars * 2+ v)*2; // Set all enable variable = 1 (Intialize)
    }
    ```

8. For each CI (Below uses positive unateness checking as an example):
    1. Derive the assumptions (cofactor variables, equivalence enables, and the output polarity)

        

        ```cpp
        // Check positive unateness (F_(~x) ^ ~F_x)
        assumptions[v] += 1; // Set the enable variable for the current input as 0
        assumptions[Aig_ManCiNum(pAig)] = (pCnf->pVarNums[aObj->Id] * 2); // Positive unate input
        assumptions[Aig_ManCiNum(pAig) + 1] = (pCnf->pVarNums[aObj->Id] + pCnf -> nVars) * 2 + 1; // Negative unate input
        assumptions[Aig_ManCiNum(pAig) + 2] = (pCnf->pVarNums[poObj->Id] * 2 + 1); // Negative output for the positive unate CNF
        assumptions[Aig_ManCiNum(pAig) + 3] = (pCnf->pVarNums[poObj->Id] + pCnf -> nVars) * 2; // Positive output for the negative unate CNF
        ```

    2. Solve the SAT problem
    3. Collect results
9. Output results

---
## Other Details

- Inputs that are not in the support set of the output should be put in both negative unate list and positive unate list.
- Abc_NtkCreateCone() may complement the output node, therefore we have to check whether the polarity of the result PO is different from the original PO. If so, then we should exchange the negative unate list and the positive unate list.